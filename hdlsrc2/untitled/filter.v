// ------------------------------------------------------------
// 
// File Name: hdlsrc2/untitled/filter
// Created: 2020-12-08 10:07:08
// Generated by MATLAB 9.9 and HDL Coder 3.17
// 
// ------------------------------------------------------------
// 
// 
// ------------------------------------------------------------
// 
// Module: filter
// Source Path: /filter
// 
// ------------------------------------------------------------
// 
// HDL Implementation    : Partly Serial
// Folding Factor        : 8
// Multipliers           : 3



`timescale 1 ns / 1 ns

module filter
               (
                clk,
                enb_8_1_1,
                reset,
                filter_in,
                filter_out
                );

  input   clk; 
  input   enb_8_1_1; 
  input   reset; 
  input   signed [13:0] filter_in; //sfix14_En13
  output  signed [17:0] filter_out; //sfix18_En13

////////////////////////////////////////////////////////////////
//Module Architecture: filter
////////////////////////////////////////////////////////////////
  // Local Functions
  // Type Definitions
  // Constants
  parameter signed [29:0] scaleconst1 = 30'b000000000000000100111100111001; //sfix30_En21
  parameter signed [29:0] coeff_b1_section1 = 30'b000000001000000000000000000000; //sfix30_En21
  parameter signed [29:0] coeff_b2_section1 = 30'b000000000000000000000000000000; //sfix30_En21
  parameter signed [29:0] coeff_b3_section1 = 30'b111111111000000000000000000000; //sfix30_En21
  parameter signed [29:0] coeff_a2_section1 = 30'b111111110011001100000110000000; //sfix30_En21
  parameter signed [29:0] coeff_a3_section1 = 30'b000000000111111100001010000000; //sfix30_En21
  parameter signed [29:0] scaleconst2 = 30'b000000000000000100111100111001; //sfix30_En21
  parameter signed [29:0] coeff_b1_section2 = 30'b000000001000000000000000000000; //sfix30_En21
  parameter signed [29:0] coeff_b2_section2 = 30'b000000000000000000000000000000; //sfix30_En21
  parameter signed [29:0] coeff_b3_section2 = 30'b111111111000000000000000000000; //sfix30_En21
  parameter signed [29:0] coeff_a2_section2 = 30'b111111110011000001010010000000; //sfix30_En21
  parameter signed [29:0] coeff_a3_section2 = 30'b000000000111111100010000000000; //sfix30_En21
  parameter signed [29:0] scaleconst3 = 30'b000000000000000100111011010000; //sfix30_En21
  parameter signed [29:0] coeff_b1_section3 = 30'b000000001000000000000000000000; //sfix30_En21
  parameter signed [29:0] coeff_b2_section3 = 30'b000000000000000000000000000000; //sfix30_En21
  parameter signed [29:0] coeff_b3_section3 = 30'b111111111000000000000000000000; //sfix30_En21
  parameter signed [29:0] coeff_a2_section3 = 30'b111111110011001101001100000000; //sfix30_En21
  parameter signed [29:0] coeff_a3_section3 = 30'b000000000111110110110110000000; //sfix30_En21
  parameter signed [29:0] scaleconst4 = 30'b000000000000000100111011010000; //sfix30_En21
  parameter signed [29:0] coeff_b1_section4 = 30'b000000001000000000000000000000; //sfix30_En21
  parameter signed [29:0] coeff_b2_section4 = 30'b000000000000000000000000000000; //sfix30_En21
  parameter signed [29:0] coeff_b3_section4 = 30'b111111111000000000000000000000; //sfix30_En21
  parameter signed [29:0] coeff_a2_section4 = 30'b111111110011001000101010000000; //sfix30_En21
  parameter signed [29:0] coeff_a3_section4 = 30'b000000000111110110111100000000; //sfix30_En21
  // Signals
  reg  signed [13:0] input_register; // sfix14_En13
  reg  [2:0] cur_count; // ufix3
  wire phase_0; // boolean
  wire phase_1; // boolean
  wire phase_2; // boolean
  wire phase_3; // boolean
  wire phase_4; // boolean
  wire phase_5; // boolean
  wire phase_6; // boolean
  wire phase_7; // boolean
  wire signed [15:0] storagetypeconvert; // sfix16_En15
  reg  signed [15:0] prev_stg_op1; // sfix16_En11
  reg  signed [15:0] prev_stg_op2; // sfix16_En11
  reg  signed [15:0] prev_stg_op3; // sfix16_En11
  reg  signed [15:0] storage_state_in1; // sfix16_En15
  reg  signed [15:0] delay_section1 [0:1] ; // sfix16_En15
  reg  signed [15:0] storage_state_in2; // sfix16_En15
  reg  signed [15:0] delay_section2 [0:1] ; // sfix16_En15
  reg  signed [15:0] storage_state_in3; // sfix16_En15
  reg  signed [15:0] delay_section3 [0:1] ; // sfix16_En15
  reg  signed [15:0] storage_state_in4; // sfix16_En15
  reg  signed [15:0] delay_section4 [0:1] ; // sfix16_En15
  wire signed [19:0] input_section1_cast; // sfix20_En15
  wire signed [19:0] storage_in_section1_cast; // sfix20_En15
  wire signed [19:0] delay_section11_cast; // sfix20_En15
  wire signed [19:0] delay_section12_cast; // sfix20_En15
  wire signed [19:0] input_section2_cast; // sfix20_En15
  wire signed [19:0] storage_in_section2_cast; // sfix20_En15
  wire signed [19:0] delay_section21_cast; // sfix20_En15
  wire signed [19:0] delay_section22_cast; // sfix20_En15
  wire signed [19:0] input_section3_cast; // sfix20_En15
  wire signed [19:0] storage_in_section3_cast; // sfix20_En15
  wire signed [19:0] delay_section31_cast; // sfix20_En15
  wire signed [19:0] delay_section32_cast; // sfix20_En15
  wire signed [19:0] input_section4_cast; // sfix20_En15
  wire signed [19:0] storage_in_section4_cast; // sfix20_En15
  wire signed [19:0] delay_section41_cast; // sfix20_En15
  wire signed [19:0] delay_section42_cast; // sfix20_En15
  wire signed [19:0] inputmux_section_1; // sfix20_En15
  wire signed [19:0] inputmux_section_2; // sfix20_En15
  wire signed [19:0] inputmux_section_3; // sfix20_En15
  wire signed [29:0] coeffmux_section_1; // sfix30_En21
  wire signed [29:0] coeffmux_section_2; // sfix30_En21
  wire signed [29:0] coeffmux_section_3; // sfix30_En21
  wire signed [49:0] prod1; // sfix50_En36
  wire signed [49:0] prod2; // sfix50_En36
  wire signed [49:0] prod3; // sfix50_En36
  wire signed [31:0] prod1_num; // sfix32_En29
  wire signed [39:0] prod1_num_cast; // sfix40_En29
  wire signed [31:0] prod1_den; // sfix32_En29
  wire signed [39:0] prod1_den_cast; // sfix40_En29
  wire signed [39:0] prod1_den_cast_neg; // sfix40_En29
  wire signed [40:0] unaryminus_temp; // sfix41_En29
  wire signed [31:0] prod2_num; // sfix32_En29
  wire signed [39:0] prod2_num_cast; // sfix40_En29
  wire signed [31:0] prod2_den; // sfix32_En29
  wire signed [39:0] prod2_den_cast; // sfix40_En29
  wire signed [39:0] prod2_den_cast_neg; // sfix40_En29
  wire signed [40:0] unaryminus_temp_1; // sfix41_En29
  wire signed [31:0] prod3_num; // sfix32_En29
  wire signed [39:0] prod3_num_cast; // sfix40_En29
  wire signed [31:0] prod3_den; // sfix32_En29
  wire signed [39:0] prod3_den_cast; // sfix40_En29
  wire signed [39:0] prod3_den_cast_neg; // sfix40_En29
  wire signed [40:0] unaryminus_temp_2; // sfix41_En29
  wire signed [39:0] prod2_mux; // sfix40_En29
  wire signed [39:0] prod3_mux; // sfix40_En29
  wire section_phase; // boolean
  wire signed [15:0] sectionipconvert; // sfix16_En16
  wire signed [39:0] sectionipconvert_cast; // sfix40_En29
  wire signed [39:0] sectionipconvert_mux; // sfix40_En29
  wire signed [39:0] sum_prod_12; // sfix40_En29
  wire signed [39:0] add_cast; // sfix40_En29
  wire signed [39:0] add_cast_1; // sfix40_En29
  wire signed [40:0] add_temp; // sfix41_En29
  wire signed [39:0] sum_prod_123; // sfix40_En29
  wire signed [39:0] add_cast_2; // sfix40_En29
  wire signed [39:0] add_cast_3; // sfix40_En29
  wire signed [40:0] add_temp_1; // sfix41_En29
  wire signed [39:0] accum_mux_out; // sfix40_En29
  wire signed [39:0] accum; // sfix40_En29
  reg  signed [39:0] accum_reg; // sfix40_En29
  wire signed [15:0] sectionopconvert; // sfix16_En11
  wire signed [17:0] output_typeconvert; // sfix18_En13
  reg  signed [17:0] output_register; // sfix18_En13

  // Block Statements
  always @ ( posedge clk)
    begin: input_reg_process
      if (reset == 1'b1) begin
        input_register <= 0;
      end
      else begin
        if (enb_8_1_1 == 1'b1) begin
          input_register <= filter_in;
        end
      end
    end // input_reg_process

  always @ (posedge clk)
    begin: Counter_process
      if (reset == 1'b1) begin
        cur_count <= 3'b000;
      end
      else begin
        if (enb_8_1_1 == 1'b1) begin
          if (cur_count >= 3'b111) begin
            cur_count <= 3'b000;
          end
          else begin
            cur_count <= cur_count + 3'b001;
          end
        end
      end
    end // Counter_process

  assign  phase_0 = (cur_count == 3'b000 && enb_8_1_1 == 1'b1) ? 1'b1 : 1'b0;

  assign  phase_1 = (cur_count == 3'b001 && enb_8_1_1 == 1'b1) ? 1'b1 : 1'b0;

  assign  phase_2 = (cur_count == 3'b010 && enb_8_1_1 == 1'b1) ? 1'b1 : 1'b0;

  assign  phase_3 = (cur_count == 3'b011 && enb_8_1_1 == 1'b1) ? 1'b1 : 1'b0;

  assign  phase_4 = (cur_count == 3'b100 && enb_8_1_1 == 1'b1) ? 1'b1 : 1'b0;

  assign  phase_5 = (cur_count == 3'b101 && enb_8_1_1 == 1'b1) ? 1'b1 : 1'b0;

  assign  phase_6 = (cur_count == 3'b110 && enb_8_1_1 == 1'b1) ? 1'b1 : 1'b0;

  assign  phase_7 = (cur_count == 3'b111 && enb_8_1_1 == 1'b1) ? 1'b1 : 1'b0;


  // Next stage input = Previous stage output. Storing Previous stage output
  always @ ( posedge clk)
    begin: prev_stg_op1_process
      if (reset == 1'b1) begin
        prev_stg_op1 <= 0;
      end
      else begin
        if (phase_1 == 1'b1) begin
          prev_stg_op1 <= sectionopconvert;
        end
      end
    end // prev_stg_op1_process

  always @ ( posedge clk)
    begin: prev_stg_op2_process
      if (reset == 1'b1) begin
        prev_stg_op2 <= 0;
      end
      else begin
        if (phase_3 == 1'b1) begin
          prev_stg_op2 <= sectionopconvert;
        end
      end
    end // prev_stg_op2_process

  always @ ( posedge clk)
    begin: prev_stg_op3_process
      if (reset == 1'b1) begin
        prev_stg_op3 <= 0;
      end
      else begin
        if (phase_5 == 1'b1) begin
          prev_stg_op3 <= sectionopconvert;
        end
      end
    end // prev_stg_op3_process

  always @ (posedge clk)
    begin: delay_process_section1
      if (reset == 1'b1) begin
        delay_section1[0] <= 16'b0000000000000000;
        delay_section1[1] <= 16'b0000000000000000;
      end
      else begin
        if (phase_1 == 1'b1) begin
          delay_section1[1] <= delay_section1[0];
          delay_section1[0] <= storage_state_in1;
        end
      end
    end // delay_process_section1

  always @ (posedge clk)
    begin: delay_process_section2
      if (reset == 1'b1) begin
        delay_section2[0] <= 16'b0000000000000000;
        delay_section2[1] <= 16'b0000000000000000;
      end
      else begin
        if (phase_3 == 1'b1) begin
          delay_section2[1] <= delay_section2[0];
          delay_section2[0] <= storage_state_in2;
        end
      end
    end // delay_process_section2

  always @ (posedge clk)
    begin: delay_process_section3
      if (reset == 1'b1) begin
        delay_section3[0] <= 16'b0000000000000000;
        delay_section3[1] <= 16'b0000000000000000;
      end
      else begin
        if (phase_5 == 1'b1) begin
          delay_section3[1] <= delay_section3[0];
          delay_section3[0] <= storage_state_in3;
        end
      end
    end // delay_process_section3

  always @ (posedge clk)
    begin: delay_process_section4
      if (reset == 1'b1) begin
        delay_section4[0] <= 16'b0000000000000000;
        delay_section4[1] <= 16'b0000000000000000;
      end
      else begin
        if (phase_7 == 1'b1) begin
          delay_section4[1] <= delay_section4[0];
          delay_section4[0] <= storage_state_in4;
        end
      end
    end // delay_process_section4

  // Making common precision for input and state
  assign input_section1_cast = $signed({input_register[13:0], 2'b00});

  assign delay_section11_cast = $signed({{4{delay_section1[0][15]}}, delay_section1[0]});

  assign delay_section12_cast = $signed({{4{delay_section1[1][15]}}, delay_section1[1]});

  assign storage_in_section1_cast = $signed({{4{storage_state_in1[15]}}, storage_state_in1});

  assign delay_section11_cast = $signed({{4{delay_section1[0][15]}}, delay_section1[0]});

  assign delay_section12_cast = $signed({{4{delay_section1[1][15]}}, delay_section1[1]});

  assign input_section2_cast = $signed({prev_stg_op1[15:0], 4'b0000});

  assign delay_section21_cast = $signed({{4{delay_section2[0][15]}}, delay_section2[0]});

  assign delay_section22_cast = $signed({{4{delay_section2[1][15]}}, delay_section2[1]});

  assign storage_in_section2_cast = $signed({{4{storage_state_in2[15]}}, storage_state_in2});

  assign delay_section21_cast = $signed({{4{delay_section2[0][15]}}, delay_section2[0]});

  assign delay_section22_cast = $signed({{4{delay_section2[1][15]}}, delay_section2[1]});

  assign input_section3_cast = $signed({prev_stg_op2[15:0], 4'b0000});

  assign delay_section31_cast = $signed({{4{delay_section3[0][15]}}, delay_section3[0]});

  assign delay_section32_cast = $signed({{4{delay_section3[1][15]}}, delay_section3[1]});

  assign storage_in_section3_cast = $signed({{4{storage_state_in3[15]}}, storage_state_in3});

  assign delay_section31_cast = $signed({{4{delay_section3[0][15]}}, delay_section3[0]});

  assign delay_section32_cast = $signed({{4{delay_section3[1][15]}}, delay_section3[1]});

  assign input_section4_cast = $signed({prev_stg_op3[15:0], 4'b0000});

  assign delay_section41_cast = $signed({{4{delay_section4[0][15]}}, delay_section4[0]});

  assign delay_section42_cast = $signed({{4{delay_section4[1][15]}}, delay_section4[1]});

  assign storage_in_section4_cast = $signed({{4{storage_state_in4[15]}}, storage_state_in4});

  assign delay_section41_cast = $signed({{4{delay_section4[0][15]}}, delay_section4[0]});

  assign delay_section42_cast = $signed({{4{delay_section4[1][15]}}, delay_section4[1]});

  assign inputmux_section_1 = (cur_count == 3'b000) ? input_section1_cast :
                             (cur_count == 3'b001) ? storage_in_section1_cast :
                             (cur_count == 3'b010) ? input_section2_cast :
                             (cur_count == 3'b011) ? storage_in_section2_cast :
                             (cur_count == 3'b100) ? input_section3_cast :
                             (cur_count == 3'b101) ? storage_in_section3_cast :
                             (cur_count == 3'b110) ? input_section4_cast :
                             storage_in_section4_cast;

  assign inputmux_section_2 = (cur_count == 3'b000) ? delay_section11_cast :
                             (cur_count == 3'b001) ? delay_section11_cast :
                             (cur_count == 3'b010) ? delay_section21_cast :
                             (cur_count == 3'b011) ? delay_section21_cast :
                             (cur_count == 3'b100) ? delay_section31_cast :
                             (cur_count == 3'b101) ? delay_section31_cast :
                             (cur_count == 3'b110) ? delay_section41_cast :
                             delay_section41_cast;

  assign inputmux_section_3 = (cur_count == 3'b000) ? delay_section12_cast :
                             (cur_count == 3'b001) ? delay_section12_cast :
                             (cur_count == 3'b010) ? delay_section22_cast :
                             (cur_count == 3'b011) ? delay_section22_cast :
                             (cur_count == 3'b100) ? delay_section32_cast :
                             (cur_count == 3'b101) ? delay_section32_cast :
                             (cur_count == 3'b110) ? delay_section42_cast :
                             delay_section42_cast;

  assign coeffmux_section_1 = (cur_count == 3'b000) ? scaleconst1 :
                             (cur_count == 3'b001) ? coeff_b1_section1 :
                             (cur_count == 3'b010) ? scaleconst2 :
                             (cur_count == 3'b011) ? coeff_b1_section2 :
                             (cur_count == 3'b100) ? scaleconst3 :
                             (cur_count == 3'b101) ? coeff_b1_section3 :
                             (cur_count == 3'b110) ? scaleconst4 :
                             coeff_b1_section4;

  assign coeffmux_section_2 = (cur_count == 3'b000) ? coeff_a2_section1 :
                             (cur_count == 3'b001) ? coeff_b2_section1 :
                             (cur_count == 3'b010) ? coeff_a2_section2 :
                             (cur_count == 3'b011) ? coeff_b2_section2 :
                             (cur_count == 3'b100) ? coeff_a2_section3 :
                             (cur_count == 3'b101) ? coeff_b2_section3 :
                             (cur_count == 3'b110) ? coeff_a2_section4 :
                             coeff_b2_section4;

  assign coeffmux_section_3 = (cur_count == 3'b000) ? coeff_a3_section1 :
                             (cur_count == 3'b001) ? coeff_b3_section1 :
                             (cur_count == 3'b010) ? coeff_a3_section2 :
                             (cur_count == 3'b011) ? coeff_b3_section2 :
                             (cur_count == 3'b100) ? coeff_a3_section3 :
                             (cur_count == 3'b101) ? coeff_b3_section3 :
                             (cur_count == 3'b110) ? coeff_a3_section4 :
                             coeff_b3_section4;
  assign prod1 = inputmux_section_1 * coeffmux_section_1;

  assign prod2 = inputmux_section_2 * coeffmux_section_2;

  assign prod3 = inputmux_section_3 * coeffmux_section_3;

  assign prod1_num = (prod1[38:0] + {prod1[7], {6{~prod1[7]}}})>>>7;

  assign prod1_num_cast = $signed({{8{prod1_num[31]}}, prod1_num});

  assign prod1_den = (prod1[38:0] + {prod1[7], {6{~prod1[7]}}})>>>7;

  assign prod1_den_cast = $signed({{8{prod1_den[31]}}, prod1_den});

  assign unaryminus_temp = (prod1_den_cast==40'b1000000000000000000000000000000000000000) ? $signed({1'b0, prod1_den_cast}) : -prod1_den_cast;
  assign prod1_den_cast_neg = unaryminus_temp[39:0];

  assign prod2_num = (prod2[38:0] + {prod2[7], {6{~prod2[7]}}})>>>7;

  assign prod2_num_cast = $signed({{8{prod2_num[31]}}, prod2_num});

  assign prod2_den = (prod2[38:0] + {prod2[7], {6{~prod2[7]}}})>>>7;

  assign prod2_den_cast = $signed({{8{prod2_den[31]}}, prod2_den});

  assign unaryminus_temp_1 = (prod2_den_cast==40'b1000000000000000000000000000000000000000) ? $signed({1'b0, prod2_den_cast}) : -prod2_den_cast;
  assign prod2_den_cast_neg = unaryminus_temp_1[39:0];

  assign prod3_num = (prod3[38:0] + {prod3[7], {6{~prod3[7]}}})>>>7;

  assign prod3_num_cast = $signed({{8{prod3_num[31]}}, prod3_num});

  assign prod3_den = (prod3[38:0] + {prod3[7], {6{~prod3[7]}}})>>>7;

  assign prod3_den_cast = $signed({{8{prod3_den[31]}}, prod3_den});

  assign unaryminus_temp_2 = (prod3_den_cast==40'b1000000000000000000000000000000000000000) ? $signed({1'b0, prod3_den_cast}) : -prod3_den_cast;
  assign prod3_den_cast_neg = unaryminus_temp_2[39:0];

  assign prod2_mux = (cur_count == 3'b000) ? prod2_den_cast_neg :
                    (cur_count == 3'b001) ? prod2_num_cast :
                    (cur_count == 3'b010) ? prod2_den_cast_neg :
                    (cur_count == 3'b011) ? prod2_num_cast :
                    (cur_count == 3'b100) ? prod2_den_cast_neg :
                    (cur_count == 3'b101) ? prod2_num_cast :
                    (cur_count == 3'b110) ? prod2_den_cast_neg :
                    prod2_num_cast;
  assign prod3_mux = (cur_count == 3'b000) ? prod3_den_cast_neg :
                    (cur_count == 3'b001) ? prod3_num_cast :
                    (cur_count == 3'b010) ? prod3_den_cast_neg :
                    (cur_count == 3'b011) ? prod3_num_cast :
                    (cur_count == 3'b100) ? prod3_den_cast_neg :
                    (cur_count == 3'b101) ? prod3_num_cast :
                    (cur_count == 3'b110) ? prod3_den_cast_neg :
                    prod3_num_cast;
  assign section_phase =  phase_0 | phase_2 | phase_4 | phase_6;

  assign sectionipconvert = (prod1[35:0] + {prod1[20], {19{~prod1[20]}}})>>>20;

  assign sectionipconvert_cast = $signed({sectionipconvert[15:0], 13'b0000000000000});

  assign sectionipconvert_mux = (section_phase == 1'b1) ? sectionipconvert_cast :
                               prod1_num_cast;
  assign add_cast = sectionipconvert_mux;
  assign add_cast_1 = prod2_mux;
  assign add_temp = add_cast + add_cast_1;
  assign sum_prod_12 = add_temp[39:0];

  assign add_cast_2 = sum_prod_12;
  assign add_cast_3 = prod3_mux;
  assign add_temp_1 = add_cast_2 + add_cast_3;
  assign sum_prod_123 = add_temp_1[39:0];

  assign accum_mux_out = sum_prod_123;

  always @ ( posedge clk)
    begin: accumulator_reg_process
      if (reset == 1'b1) begin
        accum_reg <= 0;
      end
      else begin
        if (enb_8_1_1 == 1'b1) begin
          accum_reg <= accum_mux_out;
        end
      end
    end // accumulator_reg_process

  assign storagetypeconvert = (accum_mux_out[29:0] + {accum_mux_out[14], {13{~accum_mux_out[14]}}})>>>14;

  assign sectionopconvert = (accum_mux_out[33:0] + {accum_mux_out[18], {17{~accum_mux_out[18]}}})>>>18;

  assign output_typeconvert = (accum_mux_out[33:0] + {accum_mux_out[16], {15{~accum_mux_out[16]}}})>>>16;

  always @ ( posedge clk)
    begin: storage_reg1_process
      if (reset == 1'b1) begin
        storage_state_in1 <= 0;
      end
      else begin
        if (phase_0 == 1'b1) begin
          storage_state_in1 <= storagetypeconvert;
        end
      end
    end // storage_reg1_process

  always @ ( posedge clk)
    begin: storage_reg2_process
      if (reset == 1'b1) begin
        storage_state_in2 <= 0;
      end
      else begin
        if (phase_2 == 1'b1) begin
          storage_state_in2 <= storagetypeconvert;
        end
      end
    end // storage_reg2_process

  always @ ( posedge clk)
    begin: storage_reg3_process
      if (reset == 1'b1) begin
        storage_state_in3 <= 0;
      end
      else begin
        if (phase_4 == 1'b1) begin
          storage_state_in3 <= storagetypeconvert;
        end
      end
    end // storage_reg3_process

  always @ ( posedge clk)
    begin: storage_reg4_process
      if (reset == 1'b1) begin
        storage_state_in4 <= 0;
      end
      else begin
        if (phase_6 == 1'b1) begin
          storage_state_in4 <= storagetypeconvert;
        end
      end
    end // storage_reg4_process

  always @ ( posedge clk)
    begin: Output_Register_process
      if (reset == 1'b1) begin
        output_register <= 0;
      end
      else begin
        if (phase_7 == 1'b1) begin
          output_register <= output_typeconvert;
        end
      end
    end // Output_Register_process

  // Assignment Statements
  assign filter_out = output_register;
endmodule  // filter
